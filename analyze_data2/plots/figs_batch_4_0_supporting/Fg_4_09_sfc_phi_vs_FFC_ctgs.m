% This code works with the results of permutation tests
% Tests differences in Amp & Phase across category schemes.
% Data should be generated by run_analysis.m AND with:
%     sfc_mode = *.?????1
%     OR, equivalently, folders ending in _permu


function wrkspc_buffer = Fg_4_09_sfc_phi_vs_FFC_ctgs(wrkspc_buffer,opts_exclude, sfc_mode, groupmode,sp_theshold)

if ~exist('wrkspc_buffer','var'); wrkspc_buffer = struct; end

% SFC mode

% SFC mode
% sfc_mode =  22.401311100;
perm_mode = 22.401411101;
% sfc_mode =  2.201901101;
% sfc_mode =  2.251111100;

% perm_mode = 2.201911101;
% sfc_mode = 2.201911101;
% sfc_mode = 2.241711102;
% sfc_mode = 2.2417111;
% sfc_mode = 2.2517111;
% sfc_mode = 2.251711103;
% sfc_mode = 2.271711101;
% perm_mode = 5;
% sfc_mode = 41.6018111;
% perm_mode = 41.6018111;
% sfc_mode  = 52.770201001;
% perm_mode = 52.700001001;



% Stage selection
curr_stage_sfc = 3;
curr_stage_sp = 3;

    % Pls switches
    freqband_stats = [16 20];
    freqband_stats_perm = [16 20];
    freqband_stats = [20 25];
%     freqband_stats_perm = [1 10];
%     freqband_stats = [10 12];
%     freqband_stats_perm = [9 11];
%     freqband_stats_perm = [8 10];
%     freqband_stats_perm = [10 12];
%     freqband_stats = [30 40];
%     freqband_stats_perm = [30 40];
%     freqband_stats_perm = [80 100];



    warning('To do - implement Buschmann figure.');
    warning('Add horizontal bar in perm figures to indicate value expected by chance');
    warning('Remove alpha vertical line');
    warning('Redo spectrograms without showing T stage');

    % More pls switches
    opts_pls = Opts_Pls;
    opts_pls.plotmode = 1;                   % 1-SFC; 2-PSD; 3-time series; 4-phase; 5-SpkPSD; 6- Abs(Cave*exp(i*phi)); 7 - angle(Cave*exp(i*phi)); 8-Cave*exp(i*phi))
    opts_pls.permdat2pls = 0; % Instead of using Cave from sfc_mode, use Cave1 and Cave2 data from perm_mode
    opts_pls.perm2pls = 1;                   % Instead of using Cave from sfc_mode, show differences between Cave1 and Cave2 normalized by shuffle (zscore)
        opts_pls.perm2pls_do_bh = 0;         % Do bh stepup instead of basic test
        opts_pls.perm2pls_dophi = 1;
        opts_pls.perm2pls_return_mode = 4;                 % Return mode of perm2pls (4=zscore)
        opts_pls.perm2pls_allow_signed = 0;                % 0=Abs(Diff); 1=Diff;
        opts_pls.perm2pls_split_plusminus = 0;             % 0-Return everything; 1-return pos+negative in separate columns; 2-return only positive (pls.*Ramp(Diff)); 3-return only negative (pls.*Ramp(-Diff)); 4-return only significant cells (doesn't really have a use now)
        opts_pls.sort_pls = 0;               % Sort into preferred and non-preferred
        opts_pls.swap_pls = [];
        %opts_pls.swap_pls = [2,4;5,7];      
        opts_pls.do_diff = 0;                % Take difference between adjacent pls (pls(:,:,2) - pls(:,:,1))
    opts_pls.target_pls_format = 0; % Convert pls to match this format!
        

    % Permutation test options
    opts_perm = Opts_Perm;
    opts_perm.do_bh0 = 1;
    opts_perm.do_phi = 0;
    opts_perm.split_plusminus = 0;
%     opts_perm.alpha0 = .05;
    
    % Plotting options
    paperfig_mode = 1;
    opts_PM3Dcs.paperfig_mode=paperfig_mode;
    opts_PM3Dcs.stats_mode = 0;
    opts_PM3Dsp.paperfig_mode=paperfig_mode;
    opts_PSC.paperfig_mode = paperfig_mode;
    opts_PSC.remove_dependent = 0;
    
    warning('To do - compare sch sensitive electrodes ability to attenuate irrelevant ctg response to other electrodes.');

%% Plot switches
plot_on_spect = 1;
plot_on_spectrogram = 0;
plot_on_scatter = 0;
plot_on_bargraph = 1;

% groupmode = 1;   % 0-Use default grouping (all pairs, enumerate over ctgs);
%                  % 1-Group based on permutation test output for diff.
%                  % 2-Group based on permutation test output all.
    swap_mode = 0;

group_do_merge = 0;
    grouppmerge_do_percent = 1;


%% Import data if running as a function; define dependent parameters

running_as_script = ~is_calledby;
if ~running_as_script
    pop_workspace(false);
end

        
%% Load pls
[wrkspc_buffer, out_pls] = load_pls(wrkspc_buffer,sfc_mode,curr_stage_sfc,freqband_stats,opts_exclude,opts_pls);
pls = out_pls.pls;
pls_stats = out_pls.pls_stats;
abscissa = out_pls.abscissa;
abscissa2 = out_pls.abscissa2;
bad_any = out_pls.bad_any;
funames1D = out_pls.funames1D;
mypairs = out_pls.mypairs;
group0 = out_pls.group;
sfc_mode = out_pls.sfc_mode;
clear out_pls

% pls = pls * -1;
% pls_stats = pls_stats * -1;


%% Build group

% Group based on perm_mode
if ~exist('group','var')
    switch groupmode
        case 0
            % Use default grouping (all pairs, enumerate over ctgs)
            group = group0;
            sp = ~bad_any(:);

        case 1
            % Load sp's
            [wrkspc_buffer, out_perm] = load_pr(wrkspc_buffer,perm_mode,curr_stage_sp,freqband_stats_perm,bad_any,opts_perm,opts_exclude);
            sp = out_perm.sig_cells;
            
            % Load bads perm
            [bad_any_perm] = load_bads(perm_mode,curr_stage_sp,opts_exclude,wrkspc_buffer.currmd.md,out_perm.mypairs,out_perm.funames1D);
            
            % Map sp's as needed
            [sp] = map_sp(perm_mode, sfc_mode,out_perm.mypairs,mypairs,sp,wrkspc_buffer.currmd.md,bad_any_perm,bad_any,sp_theshold);

            % Create group template
            mycrit = [2*ones(1,size(sp,2))];
            grt = group0(1);
            grt.criteria = mycrit; grt.criteria_alt = []; grt.criteria_sfc = []; grt.ctgs = 1;

            % Run a simple test
            clear group
            i=0;
%             i=i+1; group(i)=grt; group(i).criteria(1:2)=[1 0]; group(i).ctgs=1;   % Ctg1-2 deciders
%             i=i+1; group(i)=grt; group(i).criteria(1:2)=[1 0]; group(i).ctgs=2;   % Ctg1-2 non-deciders
%             i=i+1; group(i)=grt; group(i).criteria(1:2)=[0 1]; group(i).ctgs=1;   % Ctg1-2 deciders
%             i=i+1; group(i)=grt; group(i).criteria(1:2)=[0 1]; group(i).ctgs=2;   % Ctg1-2 deciders
%             i=i+1; group(i)=grt; group(i).criteria(3:4)=[1 0]; group(i).ctgs=3;   % Ctg1-2 deciders
%             i=i+1; group(i)=grt; group(i).criteria(3:4)=[1 0]; group(i).ctgs=4;   % Ctg1-2 non-deciders
%             i=i+1; group(i)=grt; group(i).criteria(3:4)=[0 1]; group(i).ctgs=3;   % Ctg1-2 deciders
%             i=i+1; group(i)=grt; group(i).criteria(3:4)=[0 1]; group(i).ctgs=4;   % Ctg1-2 deciders
%             
            if ~opts_exclude.excludeL
                i=i+1; group(i)=grt; group(i).criteria(1:2)=[1 2]; group(i).ctgs=1;   % Ctg1-2 deciders
                i=i+1; group(i)=grt; group(i).criteria(1:2)=[0 2]; group(i).ctgs=1;   % Ctg1-2 non-deciders
            end
            if ~opts_exclude.excludeO
                i=i+1; group(i)=grt; group(i).criteria(1:2)=[2 1]; group(i).ctgs=2;   % Ctg1-2 deciders
                i=i+1; group(i)=grt; group(i).criteria(1:2)=[2 0]; group(i).ctgs=2;   % Ctg1-2 deciders
            end
            
%             switch swap_mode
%                 case 0;
%                     swap_map = [1,2,3,4; [1,2,3,4] ];   % Identity
%                 case 1; swap_map = [1,2; [3,4] ];       % Irrelevant instead of relevant
%                 case 2; swap_map = [1,2; [1,3] ];       % Ctg1 Rel vs Irrel
%                 case 3; swap_map = [1,2; [2,4] ];       % Ctg2 Rel vs Irrel
%                 case 4; swap_map = [1 2; [9 10] ];             % schA schB
%                 case 5; swap_map = [1:4; 5:8 ];             % FOR CTGSETLI MODE 7
%             end
%             swap_map_pref = unique(round(swap_map/2)','rows')'; 

%             group = group_swap.crit_move (group,swap_map);      % THIS BUGGERS UP WHEN USING CTG 11
%             group = group_swap.ctgs (group,swap_map);

            % Calculate legend entries
            group = group.query_legend(group0);


   

    end
end

%% Load data into groups
group = get_grouped_cells_and_data(group,sp,pls,abscissa,mypairs,bad_any,opts_pls.plotmode,freqband_stats,funames1D,abscissa2);

if group_do_merge
    % Flip if ctgsetli mode = 4 or 5.
    temp=1:length(group);
    N=length(group);
    temp=flipud(reshape(1:N,2,floor(N/2)));
    temp=temp(:);
    group = grouppairs_merge(group(temp),opts_pls.perm2pls_dophi,grouppmerge_do_percent);
end

%% Test Plot groups, at last
opts_PM3D = {'do_mean',1,'do_zscore',0,'showErrorbars',1};
if plot_on_spect
    
    
    inds = 1:length(group);

    if get_iscromer && groupmode == 0
        if length(group) > 5
            inds=[1:4,9,10];
        else
            inds=[1,2,5];
        end
    end
            
%     inds = [1:2,9:10];
%     inds = [9:12];
    figure;
    [h1] = plot_matrix3D_custstruct([],group(inds),opts_PM3D,opts_PM3Dcs);
    
end

if 0
    %%
    figure;
    inds = [1,2,3,4,9,10];
    [h1] = plot_matrix3D_custstruct([],group(inds),opts_PM3D);
%     figure;
%     inds = 3:4;
%     [h1] = plot_matrix3D_custstruct([],group(inds),opts_PM3D);

end


%% Test bargraph

if plot_on_bargraph
    fign; [h1, h, p, out.PSC] = plot_stats_custstruct(group,opts_PSC);
end


%% Package outputs

% Package data if this script is called by a parent function
if is_calledby
    out.wrkspc_buffer = wrkspc_buffer;
    out.group = group;
    out.bad_any = bad_any;
    out.pls = pls;
    out.pls_stats = pls_stats;
    out.abscissa = abscissa;
    out.mypairs = mypairs;
end


